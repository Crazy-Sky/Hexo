---
title: 213. 打家劫舍 II
date: 2020-06-30 14:03:00
tag: [动态规划]
categories: LeetCode
toc: true
thumbnail: /thumbnails/LeetCode/leetcode.png
---

leetcode 213. 打家劫舍 II

<!--more-->

---

**题目：[213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)**

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

**示例1:**

> 输入: [2,3,2]
> 输出：3
> 解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。

**示例2:**

> 输入: [1,2,3,1]
> 输出：4
> 解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。偷窃到的最高金额 = 1 + 3 = 4。

## 方法：动态规划

**思路：**动态规划，状态转移方程为：f(i) = max(f(i - 1), f(i - 2) + nums[i])。由于房屋围成了一个圈，为了避免同时偷窃第一个房屋和最后一个房屋，因此将该问题分为两个子问题进行处理，一个是从第二个房屋到最后一个房屋进行偷窃的最高金额，另一个是从第一个房屋到倒数第二个房屋进行偷窃的最高金额。两个子问题的最优解即为该问题的最优解。
**运行数据：**执行用时：0 ms，内存消耗：36.2 MB

**复杂度分析：**

* 时间复杂度：O(n)，n为房间数，循环执行 n次。
* 空间复杂度：O(1)，常数个变量作为辅助空间。

```java
// LeetCode指定调用方法 
public int rob(int[] nums) {

    if (nums == null || nums.length == 0) {
        return 0;
    }

    int n = nums.length;

    if (n == 1) {
        return nums[0];
    }

    // dp(nums, 0, n - 2) ： 从第二个房屋到最后一个房屋进行偷窃的最高金额
    // dp(nums, 1, n - 1) ： 从第一个房屋到倒数第二个房屋进行偷窃的最高金额
    return Math.max(dp(nums, 0, n - 2), dp(nums, 1, n - 1));

}

// 动态规划
private int dp(int[] nums, int start, int end) {

    int f = 0, f1 = 0, f2 = 0;

    for (int i = start; i <= end; i++) {
        f2 = f1;
        f1 = f;
        f = Math.max(f1, f2 + nums[i]);
    }

    return f;
}
```

---

**学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。**

**才疏学浅，若有错误或不当之处，可批评指正，还请见谅！**