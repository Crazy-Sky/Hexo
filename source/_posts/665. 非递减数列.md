---
title: 665. 非递减数列
date: 2020-04-27 15:31:00
tag: [贪心]
categories: LeetCode
toc: true
thumbnail: /thumbnails/LeetCode/leetcode.png
---

leetcode 665. 非递减数列

<!--more-->

---

**题目：[665. 非递减数列](https://leetcode-cn.com/problems/non-decreasing-array/)**

给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。

我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 <= i <= n-2)，总满足 nums[i] <= nums[i + 1]。

**示例1:**

> 输入: nums = [4,2,3]
> 输出: true
> 解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。

**示例2:**

> 输入: nums = [4,2,1]
> 输出: false
> 解释: 你不能在只改变一个元素的情况下将其变为非递减数列。

**说明:**

* 1 <= n <= 10 ^ 4
* -10 ^ 5 <= nums[i] <= 10 ^ 5

## 方法：贪心

**思路：**遍历数组，如遇到当前值比后一个值大时，根据当前的值的前后值做相应修改，以保证为非递减数列，当出现两次，当前值比后一个值大时直接返回false，如果遍历完之后只出现一次或者零次当前值比后一个值大的情况则返回true。修改时应尽可能往小了修改，从而保证能够得到非递减数列。

**运行数据：**执行用时：1 ms，内存消耗：41 MB

```java
// LeetCode指定调用方法
public boolean checkPossibility(int[] nums) {
		
    int len = nums.length;
    int count = 0;
    for (int i = 0; i < len - 1; i++) {

        // 当前值比后一个值小时跳过，当前值比后一个值大时做相应修改
        if (nums[i] <= nums[i + 1]) continue;

        // 当出现两次，当前值比后一个值大时直接返回false
        count++;
        if (count > 1) return false;

        // 当前一个值比后一个值大时，此时隐含着当前值比后一个大值（循环中第一个if没进去的隐含条件），前一个值比当前值小（已遍历的数据必会满足这一点），为了尽可能是被修改的值小且满足非递减数组，应将当前值赋值给后一个值
        // 否则时，此时隐含着前一个值比后一个值小或者相等（否则时的条件），当前值比后一个大值，前一个值比当前值小，为了尽可能是被修改的值小且满足非递减数组，应将后一个值赋值给当前值
        if (i != 0 && nums[i - 1] > nums[i + 1]) {
            nums[i + 1] = nums[i];
        } else {
            nums[i] = nums[i + 1];
        }
    }

    return true;
}
```

**学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。**

**才疏学浅，若有错误或不当之处，可批评指正，还请见谅！**