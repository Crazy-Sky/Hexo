---
title: 70. 爬楼梯
date: 2020-06-26 14:43:00
tag: [动态规划, 搜索, 回溯]
categories: LeetCode
toc: true
thumbnail: /thumbnails/LeetCode/leetcode.png
---

leetcode 70. 爬楼梯

<!--more-->

---

**题目：[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)**

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意:** 给定 n 是一个正整数。

**示例1:**

> 输入： 2
> 输出： 2
> 解释： 有两种方法可以爬到楼顶。
> 1.  1 阶 + 1 阶
> 2.  2 阶

**示例2:**

> 输入： 3
> 输出： 3
> 解释： 有三种方法可以爬到楼顶。
> 1.  1 阶 + 1 阶 + 1 阶
> 2.  1 阶 + 2 阶	
> 3.  2 阶 + 1 阶

**提示:**

* 皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。

## 方法一：动态规划

**思路：**动态规划，状态转移方程为：f(n) = f(n - 1) + f(n - 2)，由于一次只能爬一阶或两阶楼梯，爬到n阶楼梯，必须从n - 1阶或者n - 2阶楼梯爬，所以爬到n阶楼梯的方法总数即为爬到n - 1 阶和爬到n - 2阶楼梯的方法总和。
**运行数据：**执行用时：0 ms，内存消耗：35.4 MB

**复杂度分析：**

* 时间复杂度：O(n)，循环执行 n次。
* 空间复杂度：O(1)，常数个变量作为辅助空间。

```java
// LeetCode指定调用方法 
public int climbStairs(int n) {
		
    int f = 1, f1 = 0, f2 = 0;

    while (n-- > 0) {
        f2 = f1;
        f1 = f;
        f = f1 + f2;
    }

    return f;
}
```

## 方法二：Backtracking（回溯）

**思路：**Backtracking（回溯），通过回溯找出每一种爬楼梯的方法，然后对其进行统计，虽然本题不用求爬楼梯的具体方法，使用此方法解决此题时会执行超时，但也在此提供一种解决求具体爬楼方法的思路。

**复杂度分析：**

* 时间复杂度：O(2^n)，其中 n 是楼梯总数。
* 空间复杂度：O(1)，常数个变量作为辅助空间。

```java
// LeetCode指定调用方法 
public int climbStairs(int n) {
		
    int count = 0;

    if (n == 0) {
        return 1;
    }

    for (int i = 1; i <= 2; i++) {
        if (n >= i) {
            count += climbStairs(n - i);
        }
    }

    return count;

}
```

---

**学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。**

**才疏学浅，若有错误或不当之处，可批评指正，还请见谅！**