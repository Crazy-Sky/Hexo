---
title: 198. 打家劫舍
date: 2020-06-28 14:33:00
tag: [动态规划]
categories: LeetCode
toc: true
thumbnail: /thumbnails/LeetCode/leetcode.png
---

leetcode 198. 打家劫舍

<!--more-->

---

**题目：[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)**

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**示例1:**

> 输入：[1,2,3,1]
> 输出：4
> 解释：
> * 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
> * 偷窃到的最高金额 = 1 + 3 = 4 。

**示例2:**

> 输入：[2,7,9,3,1]
> 输出：12
> 解释：
>
> * 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
> * 偷窃到的最高金额 = 2 + 9 + 1 = 12 。

**提示:**

* 0 <= nums.length <= 100
* 0 <= nums[i] <= 400

## 方法：动态规划

**思路：**动态规划，状态转移方程为：f(i) = max(f(i - 1), f(i - 2) + nums[i])，由于不能偷窃两间相邻的房屋，所以偷窃到第i个房间时的金额数肯定为偷窃到前一个房间（i - 1房间）的金额数或者偷窃到前两个房间（i - 2房间）的金额数和当前房间的总和。
**运行数据：**执行用时：0 ms，内存消耗：36.2 MB

**复杂度分析：**

* 时间复杂度：O(n)，n为房间数，循环执行 n次。
* 空间复杂度：O(1)，常数个变量作为辅助空间。

```java
// LeetCode指定调用方法 
public int rob(int[] nums) {
		
    int f = 0, f1 = 0, f2 = 0;

    for (int i = 0; i < nums.length; i++) {
        f = Math.max(f1, f2 + nums[i]);
        f2 = f1;
        f1 = f;
    }
    return f;
}
```

---

**学习所得，资料、图片部分来源于网络，如有侵权，请联系本人删除。**

**才疏学浅，若有错误或不当之处，可批评指正，还请见谅！**